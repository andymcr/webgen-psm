@Ecore(
	nsURI="http://andycarpenter.work/psm/ObjectRelationalMapping",
	nsPrefix="orm"
)
@Ecore(
	validationDelegates="http://www.eclipse.org/emf/2002/Ecore/OCL"
)
@GenModel(
	editDirectory="/work.andycarpenter.psms.orm.edit/src",
	editPluginID="work.andycarpenter.psms.orm.edit",
	childCreationExtenders="true",
	complianceLevel="6.0")
package work.andycarpenter.psms.orm

import work.andycarpenter.psms.base.Classifier
import work.andycarpenter.psms.base.ConstantContainer
import work.andycarpenter.psms.base.DataType
import work.andycarpenter.psms.base.FormalParameterList
import work.andycarpenter.psms.base.NamedDisplayElement
import work.andycarpenter.psms.base.NamedElement
import work.andycarpenter.psms.expression.Expression
import work.andycarpenter.psms.expression.Predicate
import work.andycarpenter.psms.expression.Variable

annotation "http://www.eclipse.org/emf/2002/Ecore/OCL" as OCL


class OrmModel {
	contains SerializationGroup[] serializationGroups
	contains DataType[] dataTypes
	contains Entity[] entities opposite partOf
	contains Repository[] repositories opposite partOf
	contains CollectionType[] collectionTypes
	DatabaseTechnologies databaseTechnology = "MySql"
	OrmTechnologies ormTechnology
	boolean timestampCreation
	boolean timestampUpdates
	boolean hasCustomOrmTypes
}

enum Cardinality {
	Optional
	Required = 1
	Many = 2
}

enum DatabaseTechnologies {
	MySql
	Oracle = 1
}

enum IsHasChoices {
	isA
	hasA = 1
}

enum OrmTechnologies {
	JPA
	DataMapper = 1
	Idiorm = 2
	Kohana = 3
	DoctrineORM = 4
	DoctrineODM = 5
}

enum CollectionTypes {
	Bag
	List
	OrderedSet
	Set
}

class CollectionType extends NamedElement {
	CollectionTypes collectionType
	refers Classifier[1] elementType
	String[1] persistenceType
	String[1] javaInterfaceType
	String[1] javaImplementationType
}

class SerializationGroup extends NamedElement {
}



class Entity extends Classifier {
	container OrmModel[1] partOf opposite entities
	String[1] singletonName
	String[1] pluralisedName
	refers Repository repository opposite serves
	contains Feature[] features opposite partOf
	refers Feature[] ^keys
	String tableName
	String autoKeyName
	String autoKeyPersistentType
	String autoKeyGenerationStrategy
	refers Feature[] ^unique
	refers Feature[] containerUnique
	contains ModelLabel[] labels opposite labelFor
	boolean implementsUserInterface = "false"
	boolean implementForumUser = "false"
	boolean allowFormTypeCustomisation = "false"
}


interface Label {
}

class ModelLabel extends NamedElement, Label {
	container Entity[1] labelFor opposite labels
	String[1] format
	boolean customise
	contains ModelLabelFeature[] features
}

abstract class ModelLabelFeature {
}

class ModelLabelAttribute extends ModelLabelFeature {
	refers Attribute[1] attribute
	String[1] dateFormat
}

class ModelLabelAssociation extends ModelLabelFeature {
	refers Association[1] association
	refers ModelLabel valueDisplay
}


abstract class Feature extends NamedDisplayElement {
	container Entity[1] partOf opposite features
	Cardinality cardinality
	boolean primaryKey
	boolean ^derived
	boolean customiseSet
	String[1] singletonName
	String[1] pluralisedName
	IsHasChoices booleanIsHasChoice
	String[1] columnName
	boolean[1] encodeUriKey = "false"
	boolean collectionOrmAllowAdd = "false"
	boolean collectionOrmAllowRemove = "false"
	refers SerializationGroup[] serializationGroups
}

abstract class Attribute extends Feature, Label {
	contains Expression defaultValue
	refers Attribute[] slugFields
	String validationPattern
	boolean hidden
	String[1] persistentType
	String[1] ormType
}

abstract class SingletonAttribute extends Attribute {
	boolean ^unique
	boolean containerUnique
}

abstract class CollectionAttribute extends Attribute {
}

class SingletonElement extends SingletonAttribute {
	refers DataType[1] dataType
	boolean obfuscateFormFields
	boolean caseInsensitive
	boolean encrypt
}

class CollectionElement extends CollectionAttribute {
	refers CollectionType[1] collectionType
}

enum DateDetails {
	DateOnly = 1
	TimeOnly = 2
	DateAndTime = 3
}

interface DateAttribute {
	DateDetails details
}

class SingletonDate extends SingletonAttribute, DateAttribute {
}

class CollectionDate extends CollectionAttribute, DateAttribute {
}

class SingletonURL extends SingletonAttribute {
	String displayValue
}

abstract class SingletonResource extends SingletonAttribute {
	int maximumUploadSize
	unique String[] validUploadMimeTypes
	unique String[] validUploadExtensions
	boolean uploadsWithinWebsite
	contains PathElement[] uploadPath
}

abstract class PathElement {
}

class StaticPathElement extends PathElement {
	String[1] element
}

class DatePathElement extends PathElement {
	String[1] format
}

class SingletonFile extends SingletonResource {
}

class SingletonImage extends SingletonResource {
}

class SingletonLocation extends SingletonAttribute {
}

@Ecore(constraints="onlyOneOwningEnd")
@OCL(onlyOneOwningEnd="owningEnd xor opposite.owningEnd")
abstract class Association extends Feature {
	refers Association[1] ^opposite
	boolean pseudo
	contains AssociationKey[] ^keys opposite keyFor
	boolean[1] ^container = "false"
	boolean[1] ^contains = "false"
	boolean[1] owningEnd = "false"
	boolean[1] visible = "true"
	int[1] serializationMaxDepth = "1"
	String pivotTableName
}

abstract class AssociationReference {
	derived String name get {
		if (association !== null)
			association.name
	}
	refers Association[1] association
	refers ModelLabel valueDisplay
	contains FeatureChildPath childFeature
}

abstract class FeatureChildPath {
}

enum SingletonAssociationRelationships {
	OneToOne
	ManyToOne = 1
}

class SingletonAssociation extends Association {
	SingletonAssociationRelationships associationRelationship
}

enum CollectionAssociationRelationships {
	OneToMany
	ManyToMany = 1
}

@Ecore(constraints="x")
@OCL(x="collectionType.elementType = opposite.partOf")
class CollectionAssociation extends Association {
	refers CollectionType[1] collectionType
	CollectionAssociationRelationships associationRelationship
}

class AssociationKey {
	container Association[1] keyFor opposite ^keys
	refers Feature[1] sourceFeature
	refers Feature targetFeature
}


class Repository extends NamedElement, ConstantContainer {
	refers OrmModel[1] partOf opposite repositories
	refers Entity serves opposite repository
	contains Selection[] selections opposite definedBy
	refers Selection findAll
	refers Selection findOne
}

class Selection extends NamedElement, FormalParameterList {
	container Repository definedBy opposite selections
	boolean distinct
	refers Feature[] fields
	refers Association[] joins
	contains Predicate condition
	contains Filter[] filters opposite selection
	contains Order[] ordering
	int limit = "0"
	refers Feature[] grouping
	refers Association[] selectPath
	String methodName
}

class FeatureReference extends Variable { 
	refers Feature[1] feature 
}


abstract class Order {
	contains Variable[1] path
}

class Asc extends Order {
}

class Desc extends Order {
}

class Filter extends NamedDisplayElement, FormalParameterList {
	refers Selection selection opposite filters
	contains Predicate condition
	String methodName
}
