@Ecore(
	nsURI="http://www.cs.man.ac.uk/mdsd/2010/ObjectRelationalMapping",
	nsPrefix="orm"
)
@Ecore(
	validationDelegates="http://www.eclipse.org/emf/2002/Ecore/OCL"
)
@GenModel(
	editDirectory="/uk.ac.man.cs.mdsd.orm.edit/src",
	editPluginID="uk.ac.man.cs.mdsd.orm.edit",
	childCreationExtenders="true",
	complianceLevel="6.0")
package uk.ac.man.cs.mdsd.orm

import uk.ac.man.cs.mdsd.criteria.Expression

annotation "http://www.eclipse.org/emf/2002/Ecore/OCL" as OCL

class OrmModel {
	contains DataType[] dataTypes
	contains Entity[] entities opposite partOf
	contains CollectionType[] collectionTypes
	unordered DatabaseTechnologies databaseTechnology = "MySql"
	String databasePrefix
	String databaseHost
	String databaseName
	String databaseUsername
	String databasePassword
	OrmTechnologies ormTechnology
}

enum Cardinality {
	Optional
	Required = 1
	Many = 2
}

enum DatabaseTechnologies {
	MySql
	Oracle = 1
}

enum OrmTechnologies {
	JPA
	DataMapper = 1
	Idiorm = 2
	Kohana = 3
	DoctrineORM = 4
	DoctrineODM = 5
}

abstract class NamedElement {
	@GenModel(property="None")
	String[1] name
}

abstract class NamedDisplayElement extends NamedElement {
	@GenModel(property="None")
	String[1] displayLabel
}

abstract class Classifier extends NamedDisplayElement {
}

enum CollectionTypes {
	Bag
	List
	OrderedSet
	Set
}

class CollectionType extends NamedElement {
	CollectionTypes collectionType
	refers Classifier[1] elementType
	String[1] persistenceType
	String[1] javaInterfaceType
	String[1] javaImplementationType
}

class DataType extends Classifier {
}

class EnumerationType extends DataType {
	contains EnumerationLiteral[] enumerations
}

class EnumerationLiteral extends NamedDisplayElement {
}


abstract class EntityOrView extends Classifier {
	contains ModelLabel[] displayLabels opposite labelFor
}

abstract class Feature extends NamedDisplayElement {
	String[1] columnName
	Boolean inputField
	String headerClass
	String inputClass
	String displayClass
	String footerClass
}

abstract class Attribute extends Feature {
}

abstract class Association extends Feature {
}

class ModelLabel extends NamedElement {
	container EntityOrView[1] labelFor opposite displayLabels
	String[1] format
	contains ModelLabelFeature[] features
}

abstract class ModelLabelFeature {
}

class ModelLabelAttribute extends ModelLabelFeature {
	refers Attribute[1] element
}

class ModelLabelAssociation extends ModelLabelFeature {
	refers Association[1] association
	refers ModelLabel dynamicLabel
}


class Entity extends EntityOrView {
	container OrmModel[1] partOf opposite entities
	refers Entity[] ^contains opposite ^container
	refers Entity ^container opposite ^contains
	contains EntityFeature[] features opposite parentEntity
	String tableName
	refers Feature[] ^keys
	String autoKeyName
}

abstract class EntityFeature {
	container Entity[1] parentEntity opposite features
}

abstract class EntityAttribute extends Attribute {
	String[1] persistentType
	String[1] ormType
}

abstract class SingletonAttribute extends EntityAttribute {
	boolean required
	boolean ^unique
	contains Expression defaultValue
}

abstract class CollectionAttribute extends EntityAttribute {
}

class SingletonElement extends SingletonAttribute {
	refers DataType[1] dataType
	boolean obfuscateFormFields
	boolean caseInsensitive
	boolean encrypt
}

class CollectionElement extends CollectionAttribute {
	refers CollectionType[1] collectionType
}

enum DateDetails {
	DateOnly = 1
	TimeOnly = 2
	DateAndTime = 3
}

interface DateAttribute {
	DateDetails details
}

class SingletonDate extends SingletonAttribute , DateAttribute {
}

class CollectionDate extends CollectionAttribute , DateAttribute {
}

abstract class SingletonResource extends SingletonAttribute {
	int maximumUploadSize
	unique String[] validUploadMimeTypes
	unique String[] validUploadExtensions
	boolean uploadsWithinWebsite
	String relativeUploadDirectory
}

class SingletonFile extends SingletonResource {
}

class SingletonImage extends SingletonResource {
}

class SingletonLocation extends SingletonAttribute {
}

@Ecore(constraints="onlyOneOwningEnd")
@OCL(onlyOneOwningEnd="owningEnd xor opposite.owningEnd")
abstract class EntityAssociation extends Association {
	refers EntityAssociation[1] ^opposite
	boolean[1] owningEnd
	boolean[1] bidirectional
	boolean[1] containment
	String pivotTableName
}

enum SingletonAssociationRelationships {
	OneToOne
	ManyToOne = 1
}

class SingletonAssociation extends EntityAssociation {
	boolean required
	SingletonAssociationRelationships associationRelationship
}

enum CollectionAssociationRelationships {
	OneToMany
	ManyToMany = 1
}

@Ecore(constraints="x")
@OCL(x="collectionType.elementType = opposite.parentEntity")
class CollectionAssociation extends EntityAssociation {
	refers CollectionType[1] collectionType
	CollectionAssociationRelationships associationRelationship
}


class View extends EntityOrView {
	refers EntityOrView[] encapsulates
	contains ViewFeature[] features opposite includedBy
}

abstract class ViewFeature {
	container View[1] includedBy opposite features
	String alias
}

class ViewAttribute extends ViewFeature {
	refers Attribute[1] attribute
}

class ViewAssociation extends ViewFeature {
	refers Association[1] association
}
